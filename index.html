<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spotify Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --c1: #ff006e;
      --c2: #8338ec;
      --c3: #06ffd8;
      --c4: #ffbe0b;
      --bg: #000008;
    }

    html, body {
      width: 100%; height: 100%;
      background: var(--bg);
      overflow: hidden;
      font-family: 'Orbitron', monospace;
      color: #fff;
      cursor: none;
    }

    /* Custom cursor */
    .cursor {
      position: fixed;
      width: 12px; height: 12px;
      background: var(--c3);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: screen;
      transition: transform 0.1s;
      box-shadow: 0 0 20px var(--c3);
    }

    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* LOGIN SCREEN */
    #login-screen {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg);
    }

    #login-screen::before {
      content: '';
      position: absolute;
      inset: 0;
      background:
        radial-gradient(ellipse 80% 50% at 20% 50%, rgba(131,56,236,0.15) 0%, transparent 60%),
        radial-gradient(ellipse 60% 40% at 80% 50%, rgba(255,0,110,0.12) 0%, transparent 60%);
    }

    .login-logo {
      font-size: clamp(2rem, 6vw, 5rem);
      font-weight: 900;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      background: linear-gradient(135deg, var(--c3), var(--c2), var(--c1));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.3em;
      position: relative;
      z-index: 1;
    }

    .login-sub {
      font-family: 'Share Tech Mono', monospace;
      font-size: clamp(0.7rem, 1.5vw, 1rem);
      color: rgba(255,255,255,0.4);
      letter-spacing: 0.3em;
      text-transform: uppercase;
      margin-bottom: 4rem;
      position: relative;
      z-index: 1;
    }

    .login-btn {
      position: relative;
      z-index: 1;
      padding: 1.1rem 3.5rem;
      font-family: 'Orbitron', monospace;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #000;
      background: var(--c3);
      border: none;
      cursor: pointer !important;
      clip-path: polygon(12px 0%, 100% 0%, calc(100% - 12px) 100%, 0% 100%);
      transition: all 0.2s;
      text-decoration: none;
      display: inline-block;
      -webkit-appearance: none;
      appearance: none;
    }

    .login-btn:hover {
      background: #fff;
      transform: scale(1.05);
      box-shadow: 0 0 40px var(--c3);
    }

    .scan-lines {
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.03) 2px,
        rgba(0,0,0,0.03) 4px
      );
      pointer-events: none;
      z-index: 200;
    }

    /* VISUALIZER UI */
    #ui {
      position: fixed;
      z-index: 50;
      inset: 0;
      pointer-events: none;
      display: none;
    }

    /* Track info bottom left */
    #track-info {
      position: absolute;
      bottom: 2.5rem;
      left: 2.5rem;
      max-width: 380px;
    }

    #track-name {
      font-size: clamp(1rem, 2.5vw, 1.6rem);
      font-weight: 700;
      letter-spacing: 0.05em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 0 30px currentColor;
    }

    #artist-name {
      font-family: 'Share Tech Mono', monospace;
      font-size: clamp(0.7rem, 1.2vw, 0.9rem);
      color: rgba(255,255,255,0.5);
      letter-spacing: 0.2em;
      margin-top: 0.3rem;
    }

    /* Stats top right */
    #stats {
      position: absolute;
      top: 2rem;
      right: 2.5rem;
      text-align: right;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.75rem;
      color: rgba(255,255,255,0.35);
      letter-spacing: 0.15em;
      line-height: 1.8;
    }

    .stat-val {
      color: rgba(255,255,255,0.7);
    }

    /* Progress bar */
    #progress-wrap {
      position: absolute;
      bottom: 0;
      left: 0; right: 0;
      height: 3px;
      background: rgba(255,255,255,0.05);
    }

    #progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--c2), var(--c1));
      width: 0%;
      transition: width 1s linear;
      box-shadow: 0 0 10px var(--c1);
    }

    /* Mode indicator top left */
    #mode-tag {
      position: absolute;
      top: 2rem;
      left: 2.5rem;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.25em;
      color: var(--c3);
      opacity: 0.6;
    }

    /* Album art */
    #album-art {
      position: absolute;
      bottom: 2.5rem;
      right: 2.5rem;
      width: 80px; height: 80px;
      border: 1px solid rgba(255,255,255,0.1);
      opacity: 0.7;
      transition: opacity 0.5s;
    }

    #album-art:hover { opacity: 1; }

    /* Fullscreen button */
    #fs-btn {
      position: fixed;
      bottom: 2.5rem;
      right: calc(80px + 3.5rem);
      z-index: 60;
      background: none;
      border: 1px solid rgba(255,255,255,0.15);
      color: rgba(255,255,255,0.4);
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.65rem;
      letter-spacing: 0.15em;
      padding: 0.4rem 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      display: none;
      pointer-events: all;
    }

    #fs-btn:hover {
      border-color: var(--c3);
      color: var(--c3);
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>

<div class="cursor" id="cursor"></div>
<div class="scan-lines"></div>

<!-- Canvas layers -->
<canvas id="bg-canvas"></canvas>
<canvas id="main-canvas"></canvas>

<!-- Login -->
<div id="login-screen">
  <div class="login-logo">SYNTHWAVE</div>
  <div class="login-sub">Spotify Visual Experience</div>
  <button id="login-btn" class="login-btn">Connect Spotify</button>
</div>

<!-- Visualizer UI overlay -->
<div id="ui">
  <div id="mode-tag">LIVE VISUAL ENGINE</div>
  <div id="stats">
    BPM <span class="stat-val" id="stat-bpm">—</span><br>
    ENERGY <span class="stat-val" id="stat-energy">—</span><br>
    KEY <span class="stat-val" id="stat-key">—</span><br>
    MOOD <span class="stat-val" id="stat-mood">—</span>
  </div>
  <div id="track-info">
    <div id="track-name">—</div>
    <div id="artist-name">—</div>
  </div>
  <img id="album-art" src="" alt="" />
  <div id="progress-wrap"><div id="progress-bar"></div></div>
</div>

<button id="fs-btn">⛶ FULLSCREEN</button>

<script>
// ─── CONFIG ───────────────────────────────────────────────────────────────────
const CLIENT_ID = window.SPOTIFY_CLIENT_ID || 'c4a8270f8bc6453490fc8bf4b9de5c42';
const REDIRECT_URI = window.location.origin + '/callback';
const SCOPES = [
  'user-read-currently-playing',
  'user-read-playback-state',
  'streaming',
  'user-modify-playback-state'
].join(' ');

// ─── AUTH ─────────────────────────────────────────────────────────────────────
function getAuthURL() {
  const params = new URLSearchParams({
    client_id: CLIENT_ID,
    response_type: 'token',
    redirect_uri: REDIRECT_URI,
    scope: SCOPES,
    show_dialog: true
  });
  return `https://accounts.spotify.com/authorize?${params}`;
}

function getToken() {
  const hash = window.location.hash.substring(1);
  console.log('[Auth] hash present:', !!hash);
  console.log('[Auth] pathname:', window.location.pathname);
  if (hash) {
    const p = new URLSearchParams(hash);
    const t = p.get('access_token');
    if (t) {
      console.log('[Auth] Token found! Saving to localStorage.');
      localStorage.setItem('sp_token', t);
      localStorage.setItem('sp_token_ts', Date.now());
      window.history.replaceState({}, document.title, '/');
      return t;
    } else {
      console.log('[Auth] Hash present but no access_token. Hash was:', hash.substring(0,80));
    }
  }
  const stored = localStorage.getItem('sp_token');
  const ts = parseInt(localStorage.getItem('sp_token_ts') || '0');
  if (stored && Date.now() - ts < 3600000) {
    console.log('[Auth] Using stored token');
    return stored;
  }
  console.log('[Auth] No token available.');
  return null;
}

const loginBtn = document.getElementById('login-btn');
loginBtn.style.cursor = 'pointer';
loginBtn.addEventListener('click', () => {
  if (CLIENT_ID === 'YOUR_CLIENT_ID' || !CLIENT_ID) {
    alert('26a0Fe0f Client ID not set! Please replace YOUR_CLIENT_ID in index.html with your Spotify Client ID.');
    return;
  }
  const url = getAuthURL();
  console.log('Navigating to:', url);
  window.location.href = url;
});

// ─── CURSOR ───────────────────────────────────────────────────────────────────
const cursor = document.getElementById('cursor');
document.addEventListener('mousemove', e => {
  cursor.style.left = (e.clientX - 6) + 'px';
  cursor.style.top = (e.clientY - 6) + 'px';
});

// ─── CANVAS SETUP ─────────────────────────────────────────────────────────────
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');

function resize() {
  bgCanvas.width = canvas.width = window.innerWidth;
  bgCanvas.height = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ─── COLOR SYSTEM ─────────────────────────────────────────────────────────────
// Dynamic palette based on valence + energy
const PALETTES = {
  euphoric:  ['#ff006e','#ffbe0b','#06ffd8','#ff4500'],
  melancholy:['#4361ee','#7209b7','#3a0ca3','#480ca8'],
  tense:     ['#f72585','#b5179e','#560bad','#3f37c9'],
  chill:     ['#06ffd8','#4cc9f0','#4361ee','#7209b7'],
  dark:      ['#ff0a54','#ff477e','#ff85a1','#fbb1bd'],
};

let palette = PALETTES.euphoric;

function updatePalette(valence, energy) {
  if (valence > 0.6 && energy > 0.6) palette = PALETTES.euphoric;
  else if (valence < 0.4 && energy < 0.5) palette = PALETTES.melancholy;
  else if (energy > 0.7 && valence < 0.5) palette = PALETTES.tense;
  else if (energy < 0.5 && valence > 0.5) palette = PALETTES.chill;
  else palette = PALETTES.dark;
}

function pc(i) { return palette[i % palette.length]; }
function hexToRGB(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return {r,g,b};
}
function rgbStr(hex, a=1) {
  const {r,g,b} = hexToRGB(hex);
  return `rgba(${r},${g},${b},${a})`;
}

// ─── MUSIC STATE ──────────────────────────────────────────────────────────────
let state = {
  bpm: 120,
  energy: 0.5,
  valence: 0.5,
  danceability: 0.5,
  loudness: -10,
  key: 0,
  mode: 1,
  beatInterval: 500,
  lastBeat: 0,
  trackId: null,
  progress: 0,
  duration: 1,
  trackName: '',
  artistName: '',
  albumArt: '',
  beats: [],
  sections: [],
  analysisStart: 0,
};

// Smoothed values for animation
let smooth = {
  energy: 0.5,
  bpm: 120,
  beatPulse: 0,
};

// ─── PARTICLES ────────────────────────────────────────────────────────────────
class Particle {
  constructor() { this.reset(true); }
  reset(init=false) {
    this.x = Math.random() * canvas.width;
    this.y = init ? Math.random() * canvas.height : canvas.height + 10;
    this.vx = (Math.random()-0.5) * 1.5;
    this.vy = -(Math.random() * 2 + 0.5);
    this.life = 1;
    this.decay = Math.random() * 0.005 + 0.002;
    this.size = Math.random() * 3 + 1;
    this.colorIdx = Math.floor(Math.random() * 4);
    this.trail = [];
  }
  update(energy) {
    const speed = 1 + energy * 3;
    this.x += this.vx * speed;
    this.y += this.vy * speed;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 12) this.trail.shift();
    this.life -= this.decay;
    if (this.life <= 0 || this.y < -50) this.reset();
  }
  draw(ctx) {
    if (this.trail.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(this.trail[0].x, this.trail[0].y);
    for (let i = 1; i < this.trail.length; i++) {
      ctx.lineTo(this.trail[i].x, this.trail[i].y);
    }
    ctx.strokeStyle = rgbStr(pc(this.colorIdx), this.life * 0.6);
    ctx.lineWidth = this.size * this.life;
    ctx.shadowBlur = 15;
    ctx.shadowColor = pc(this.colorIdx);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // head glow
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI*2);
    ctx.fillStyle = rgbStr(pc(this.colorIdx), this.life);
    ctx.fill();
  }
}

const PARTICLE_COUNT = 120;
const particles = Array.from({length: PARTICLE_COUNT}, () => new Particle());

// ─── GEOMETRIC SHAPES ─────────────────────────────────────────────────────────
class GeoShape {
  constructor() { this.reset(); }
  reset() {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.size = Math.random() * 80 + 20;
    this.rot = Math.random() * Math.PI * 2;
    this.rotSpeed = (Math.random()-0.5) * 0.02;
    this.sides = [3,4,6,8][Math.floor(Math.random()*4)];
    this.colorIdx = Math.floor(Math.random()*4);
    this.alpha = Math.random() * 0.15 + 0.03;
    this.vx = (Math.random()-0.5) * 0.3;
    this.vy = (Math.random()-0.5) * 0.3;
    this.pulsePhase = Math.random() * Math.PI * 2;
  }
  update(t, energy) {
    this.rot += this.rotSpeed * (1 + energy);
    this.x += this.vx;
    this.y += this.vy;
    if (this.x < -200 || this.x > canvas.width+200) this.vx *= -1;
    if (this.y < -200 || this.y > canvas.height+200) this.vy *= -1;
  }
  draw(ctx, t, beatPulse) {
    const pulse = 1 + Math.sin(t * 0.002 + this.pulsePhase) * 0.1 + beatPulse * 0.3;
    const s = this.size * pulse;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);
    ctx.beginPath();
    for (let i = 0; i < this.sides; i++) {
      const angle = (i / this.sides) * Math.PI * 2 - Math.PI/2;
      const x = Math.cos(angle) * s;
      const y = Math.sin(angle) * s;
      i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.strokeStyle = rgbStr(pc(this.colorIdx), this.alpha * 3);
    ctx.lineWidth = 1.5;
    ctx.shadowBlur = 20;
    ctx.shadowColor = pc(this.colorIdx);
    ctx.stroke();
    ctx.fillStyle = rgbStr(pc(this.colorIdx), this.alpha);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

const GEO_COUNT = 18;
const geoShapes = Array.from({length: GEO_COUNT}, () => new GeoShape());

// ─── WAVEFORM ─────────────────────────────────────────────────────────────────
let wavePoints = Array(128).fill(0);
let waveTargets = Array(128).fill(0);

function updateWave(energy, bpm, t) {
  const freq = bpm / 60;
  for (let i = 0; i < wavePoints.length; i++) {
    const x = i / wavePoints.length;
    waveTargets[i] =
      Math.sin(x * Math.PI * 8 + t * freq * 0.01) * energy * 0.4 +
      Math.sin(x * Math.PI * 16 + t * freq * 0.007) * energy * 0.2 +
      Math.sin(x * Math.PI * 3 + t * 0.003) * 0.1;
    wavePoints[i] += (waveTargets[i] - wavePoints[i]) * 0.12;
  }
}

function drawWave(ctx, w, h, t, beatPulse) {
  const cx = w / 2;
  const cy = h / 2;
  const amp = h * 0.12 * (1 + beatPulse * 0.8);

  for (let layer = 0; layer < 3; layer++) {
    ctx.beginPath();
    for (let i = 0; i <= wavePoints.length; i++) {
      const idx = Math.min(i, wavePoints.length-1);
      const x = (i / wavePoints.length) * w;
      const offset = layer * 0.3;
      const y = cy + wavePoints[idx] * amp + Math.sin(t*0.001 + offset) * 20;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    const alpha = (0.6 - layer * 0.15) * smooth.energy;
    ctx.strokeStyle = rgbStr(pc(layer), alpha);
    ctx.lineWidth = 2 - layer * 0.5;
    ctx.shadowBlur = 25;
    ctx.shadowColor = pc(layer);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
}

// ─── BEAT RINGS ───────────────────────────────────────────────────────────────
let beatRings = [];

function spawnBeatRing() {
  beatRings.push({
    x: canvas.width/2 + (Math.random()-0.5)*200,
    y: canvas.height/2 + (Math.random()-0.5)*200,
    r: 0,
    maxR: Math.random() * 300 + 150,
    life: 1,
    colorIdx: Math.floor(Math.random()*4),
  });
}

function updateDrawRings(ctx) {
  beatRings = beatRings.filter(ring => ring.life > 0);
  for (const ring of beatRings) {
    ring.r += (ring.maxR - ring.r) * 0.08;
    ring.life -= 0.025;
    ctx.beginPath();
    ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI*2);
    ctx.strokeStyle = rgbStr(pc(ring.colorIdx), ring.life * 0.5);
    ctx.lineWidth = 2 * ring.life;
    ctx.shadowBlur = 30;
    ctx.shadowColor = pc(ring.colorIdx);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
}

// ─── BACKGROUND ───────────────────────────────────────────────────────────────
function drawBackground(t, energy) {
  const w = bgCanvas.width, h = bgCanvas.height;
  bgCtx.clearRect(0, 0, w, h);
  bgCtx.fillStyle = '#000008';
  bgCtx.fillRect(0, 0, w, h);

  // Slow-moving gradient orbs
  const orbs = [
    {x: 0.2 + Math.sin(t*0.0003)*0.1, y:0.5, c: pc(1)},
    {x: 0.8 + Math.cos(t*0.0002)*0.1, y:0.4, c: pc(0)},
    {x: 0.5, y: 0.8 + Math.sin(t*0.0004)*0.1, c: pc(2)},
  ];

  for (const orb of orbs) {
    const grd = bgCtx.createRadialGradient(
      orb.x*w, orb.y*h, 0,
      orb.x*w, orb.y*h, w*0.4
    );
    const {r,g,b} = hexToRGB(orb.c);
    grd.addColorStop(0, `rgba(${r},${g},${b},${0.08 + energy*0.05})`);
    grd.addColorStop(1, 'transparent');
    bgCtx.fillStyle = grd;
    bgCtx.fillRect(0,0,w,h);
  }

  // Grid lines
  bgCtx.strokeStyle = 'rgba(255,255,255,0.025)';
  bgCtx.lineWidth = 1;
  const gridSize = 60;
  for (let x = 0; x < w; x += gridSize) {
    bgCtx.beginPath();
    bgCtx.moveTo(x, 0); bgCtx.lineTo(x, h);
    bgCtx.stroke();
  }
  for (let y = 0; y < h; y += gridSize) {
    bgCtx.beginPath();
    bgCtx.moveTo(0, y); bgCtx.lineTo(w, y);
    bgCtx.stroke();
  }
}

// ─── MAIN RENDER LOOP ─────────────────────────────────────────────────────────
let lastT = 0;
function render(t) {
  requestAnimationFrame(render);
  const dt = t - lastT;
  lastT = t;

  const w = canvas.width, h = canvas.height;

  // Smooth state
  smooth.energy += (state.energy - smooth.energy) * 0.05;
  smooth.bpm += (state.bpm - smooth.bpm) * 0.02;
  smooth.beatPulse *= 0.92;

  // Beat detection
  const beatI = state.beatInterval;
  if (t - state.lastBeat > beatI) {
    state.lastBeat = t;
    smooth.beatPulse = 1;
    spawnBeatRing();
    if (Math.random() < 0.3) spawnBeatRing();
  }

  // Background
  drawBackground(t, smooth.energy);

  // Clear main
  ctx.clearRect(0, 0, w, h);

  // Trail fade
  ctx.fillStyle = `rgba(0,0,8,${0.15 + (1-smooth.energy)*0.1})`;
  ctx.fillRect(0, 0, w, h);

  // Geo shapes
  for (const s of geoShapes) {
    s.update(t, smooth.energy);
    s.draw(ctx, t, smooth.beatPulse);
  }

  // Beat rings
  updateDrawRings(ctx);

  // Waveform
  updateWave(smooth.energy, smooth.bpm, t);
  drawWave(ctx, w, h, t, smooth.beatPulse);

  // Particles
  for (const p of particles) {
    p.update(smooth.energy);
    p.draw(ctx);
  }

  // Center flash on beat
  if (smooth.beatPulse > 0.5) {
    const r = smooth.beatPulse;
    const grd = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w*0.4);
    grd.addColorStop(0, rgbStr(pc(0), r * 0.15));
    grd.addColorStop(1, 'transparent');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, w, h);
  }

  // Progress
  if (state.duration > 0) {
    const elapsed = (Date.now() - state.analysisStart) / 1000 + state.progress / 1000;
    document.getElementById('progress-bar').style.width =
      Math.min(100, (elapsed / (state.duration/1000)) * 100) + '%';
  }
}
requestAnimationFrame(render);

// ─── SPOTIFY API ──────────────────────────────────────────────────────────────
let token = null;

async function spotifyGet(endpoint) {
  const res = await fetch('https://api.spotify.com/v1/' + endpoint, {
    headers: { Authorization: 'Bearer ' + token }
  });
  if (res.status === 401) { logout(); return null; }
  if (!res.ok) return null;
  return res.json();
}

function logout() {
  localStorage.removeItem('sp_token');
  localStorage.removeItem('sp_token_ts');
  document.getElementById('login-screen').style.display = 'flex';
  document.getElementById('ui').style.display = 'none';
  document.getElementById('fs-btn').style.display = 'none';
}

const KEYS = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

async function loadTrackFeatures(trackId) {
  const features = await spotifyGet(`audio-features/${trackId}`);
  if (!features) return;

  state.bpm = features.tempo || 120;
  state.energy = features.energy || 0.5;
  state.valence = features.valence || 0.5;
  state.danceability = features.danceability || 0.5;
  state.loudness = features.loudness || -10;
  state.key = features.key >= 0 ? features.key : 0;
  state.mode = features.mode;
  state.beatInterval = (60 / state.bpm) * 1000;

  updatePalette(state.valence, state.energy);

  // Update UI stats
  document.getElementById('stat-bpm').textContent = Math.round(state.bpm);
  document.getElementById('stat-energy').textContent = Math.round(state.energy * 100) + '%';
  document.getElementById('stat-key').textContent = KEYS[state.key] + (state.mode ? ' maj' : ' min');
  document.getElementById('stat-mood').textContent =
    state.valence > 0.6 ? 'EUPHORIC' :
    state.valence > 0.4 ? 'NEUTRAL' : 'DARK';

  // Reshuffle geo shape colors
  for (const s of geoShapes) s.colorIdx = Math.floor(Math.random()*4);
}

let pollTimer = null;
let lastTrackId = null;

async function pollPlayback() {
  const data = await spotifyGet('me/player/currently-playing');
  if (!data || !data.item) return;

  const track = data.item;
  const trackId = track.id;

  state.progress = data.progress_ms || 0;
  state.duration = track.duration_ms || 1;
  state.analysisStart = Date.now();

  if (trackId !== lastTrackId) {
    lastTrackId = trackId;
    state.trackName = track.name;
    state.artistName = track.artists.map(a => a.name).join(', ');
    state.albumArt = track.album?.images?.[0]?.url || '';

    document.getElementById('track-name').textContent = state.trackName;
    document.getElementById('artist-name').textContent = state.artistName;
    if (state.albumArt) document.getElementById('album-art').src = state.albumArt;

    await loadTrackFeatures(trackId);
  }
}

function startPolling() {
  pollPlayback();
  pollTimer = setInterval(pollPlayback, 5000);
}

// ─── INIT ─────────────────────────────────────────────────────────────────────
token = getToken();

if (token) {
  document.getElementById('login-screen').style.display = 'none';
  document.getElementById('ui').style.display = 'block';
  document.getElementById('fs-btn').style.display = 'block';
  startPolling();
}

// Fullscreen
document.getElementById('fs-btn').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    document.getElementById('fs-btn').textContent = '✕ EXIT';
  } else {
    document.exitFullscreen();
    document.getElementById('fs-btn').textContent = '⛶ FULLSCREEN';
  }
});
</script>
</body>
</html>
